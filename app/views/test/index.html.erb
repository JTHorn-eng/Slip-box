<!DOCTYPE html>
<html lang="en">
    <head>
    <meta description="Threads page for Slipbox">
        <title>Threads</title>
        <%= stylesheet_link_tag "test" %>
        <%= javascript_include_tag "http://cdnjs.cloudflare.com/ajax/libs/fabric.js/1.4.0/fabric.min.js" %>

    </head>
    <body>  
        <div id="wrapper">
            <canvas id="canvas" width="1500px" height="500px" ></canvas>
        </div>
    </body>
</html>






<script>
"use strict"


class Node {

    constructor(id, val, children) {
        this.id = id;
        this.value = val;
        this.children = [];
    }

    getId() {
        return this.id;
    }

    getValue() {
        return this.value;
    }

    getChildren() {
        return this.children;
    }
    
   
    

}

class GenerateTree {

   

    findRootNode(nodeList) {
        let items = nodeList[0].split(":");
        return new Node(items[0], items[1], items[2]);
    }; 

    addNode(tree, id, node) {
        let nodeInfo = node.split(":");
        if (tree.getChildren().length > 0) {
            //recurse on child node
            for (let c in tree.getChildren()) {
                let childID = tree.getChildren()[c].getId();
                if (childID.substring(0, id+1) == node.substring(0, id+1)) {
                    if (childID.substring(0, id+2) == node.substring(0, id+2)) {
                        this.addNode(tree.getChildren()[c], id + 1, node);                        
                    } else {
                        console.log("Adding recursive step child");
                        let items = node.split(":");
                        tree.getChildren().push(new Node(items[0], items[1], items[2]));
      
                    }
                    break;
                }
            }                
        } else {
            console.log("Adding child");
            let items = node.split(":");
            tree.getChildren().push(new Node(items[0], items[1], items[2]));
       }
        return tree;
    };


    generateTree(nodeList) {
        let list = ["1:asd"];
        let tree = this.findRootNode(list);
        //initial call to recursively add a node
        
        for (let n in nodeList) {
            tree = this.addNode(tree, 0, nodeList[n]);
        }
        console.log(tree);
        return tree;
    };



}


class RenderTree {

    constructor(tree) {
        this.canvas = new fabric.Canvas('canvas');
        this.canvas.selection = false;
        this.NODE_WIDTH = 100;
        this.NODE_HEIGHT = 50;
        this.INITAL_OFF_X = 50
        this.drawTree(tree, this.canvas.width / 2, 20);
        this.canvas.renderAll();


    }


    drawNode(node, x, y) {
        let obj = new fabric.Text(node.getValue() + " " + node.getId(), 
        {
            left: x,
            top: y,
            fontFamily: 'Helvetica',
            fontSize: 16
        });

        

        obj.set('selectable', false);

        //add node to canvas
        this.canvas.add(obj);
    }

    drawTree(tree, x, y) {
        //draw node
        this.drawNode(tree, x, y);
        if (tree.getChildren() == []) {
            y += this.NODE_HEIGHT;
        }

        //recurse through tree
        for (let i in tree.getChildren()) {
            let child = tree.getChildren()[i];
            let offsetX = -(this.INITAL_OFF_X * (tree.getChildren().length - 1)) +  i * this.NODE_WIDTH;
            let cX =  (x + offsetX);
            let cY =  y + this.NODE_HEIGHT;
            console.log(child);
            this.drawTree(child, cX, cY);
        
            //draw line
            // let line = new fabric.Line([x, y, cX, cY], {});
            // line.set('selectable', false);
            // this.canvas.add(line)

        }


    }
}



let tree = new GenerateTree();
let children = []

for (let x = 0; x < 100; x++) {
    children.push("1i:asd" + x.toString())
}
let result = tree.generateTree(children);
let render = new RenderTree(result);

</script>